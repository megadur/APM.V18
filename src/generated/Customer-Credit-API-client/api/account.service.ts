/**
 * Customer Credit API
 *
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { AddanaccountHolderRequest1 } from '../model/addanaccountHolderRequest1';
// @ts-ignore
import { ChangecreditlimitofanAccountRequest1 } from '../model/changecreditlimitofanAccountRequest1';
// @ts-ignore
import { ChangetoleranceofanaccountRequest1 } from '../model/changetoleranceofanaccountRequest1';
// @ts-ignore
import { CloseanAccountRequest1 } from '../model/closeanAccountRequest1';
// @ts-ignore
import { CreateaPreAuthorizationRequest1 } from '../model/createaPreAuthorizationRequest1';
// @ts-ignore
import { CreateaPreAuthorizationUsingidRequest } from '../model/createaPreAuthorizationUsingidRequest';
// @ts-ignore
import { CreateorUpdateSettlementRequest1 } from '../model/createorUpdateSettlementRequest1';
// @ts-ignore
import { DecreasebalanceofanaccountRequest1 } from '../model/decreasebalanceofanaccountRequest1';
// @ts-ignore
import { Getaccount1 } from '../model/getaccount1';
// @ts-ignore
import { OpenanAccountRequest1 } from '../model/openanAccountRequest1';
// @ts-ignore
import { OpenorChangeAccountRequest1 } from '../model/openorChangeAccountRequest1';
// @ts-ignore
import { PartialorTotalRefundaSettlementRequest1 } from '../model/partialorTotalRefundaSettlementRequest1';
// @ts-ignore
import { Searchaccounts1 } from '../model/searchaccounts1';
// @ts-ignore
import { Searchcheckingaccounts1 } from '../model/searchcheckingaccounts1';
// @ts-ignore
import { Statements1 } from '../model/statements1';
// @ts-ignore
import { ThisoperationcausesthecreationofNinvoicesWhereNisthenumberofinstallmentsThefirstinvoicewillhaveaduedatewith30daysandthenextinvoiceswillhaveaduedate30daysawayfrompreviousinvoice } from '../model/thisoperationcausesthecreationofNinvoicesWhereNisthenumberofinstallmentsThefirstinvoicewillhaveaduedatewith30daysandthenextinvoiceswillhaveaduedate30daysawayfrompreviousinvoice';
// @ts-ignore
import { UpdateemailanddescriptionofaaccountRequest1 } from '../model/updateemailanddescriptionofaaccountRequest1';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { BaseService } from '../api.base.service';



@Injectable({
  providedIn: 'root'
})
export class AccountService extends BaseService {

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string|string[], @Optional() configuration?: Configuration) {
        super(basePath, configuration);
    }

    /**
     * Account statements
     * Get the account statements.
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param creditAccountId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public accountstatements(contentType: string, accept: string, creditAccountId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<Statements1>;
    public accountstatements(contentType: string, accept: string, creditAccountId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Statements1>>;
    public accountstatements(contentType: string, accept: string, creditAccountId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Statements1>>;
    public accountstatements(contentType: string, accept: string, creditAccountId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling accountstatements.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling accountstatements.');
        }
        if (creditAccountId === null || creditAccountId === undefined) {
            throw new Error('Required parameter creditAccountId was null or undefined when calling accountstatements.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json; charset=utf-8'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts/${this.configuration.encodeParam({name: "creditAccountId", value: creditAccountId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/statements`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Statements1>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add an account Holder
     * 
     * @param creditAccountId Credit account\&#39;s identification
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param addanaccountHolderRequest1 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public addanaccountHolder(creditAccountId: string, accept: string, contentType: string, addanaccountHolderRequest1: AddanaccountHolderRequest1, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<Searchcheckingaccounts1>;
    public addanaccountHolder(creditAccountId: string, accept: string, contentType: string, addanaccountHolderRequest1: AddanaccountHolderRequest1, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Searchcheckingaccounts1>>;
    public addanaccountHolder(creditAccountId: string, accept: string, contentType: string, addanaccountHolderRequest1: AddanaccountHolderRequest1, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Searchcheckingaccounts1>>;
    public addanaccountHolder(creditAccountId: string, accept: string, contentType: string, addanaccountHolderRequest1: AddanaccountHolderRequest1, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (creditAccountId === null || creditAccountId === undefined) {
            throw new Error('Required parameter creditAccountId was null or undefined when calling addanaccountHolder.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling addanaccountHolder.');
        }
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling addanaccountHolder.');
        }
        if (addanaccountHolderRequest1 === null || addanaccountHolderRequest1 === undefined) {
            throw new Error('Required parameter addanaccountHolderRequest1 was null or undefined when calling addanaccountHolder.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json; charset=utf-8'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts/${this.configuration.encodeParam({name: "creditAccountId", value: creditAccountId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/holders`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Searchcheckingaccounts1>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: addanaccountHolderRequest1,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Cancel a Pre Authorization
     * 
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param creditAccountId Credit account\&#39;s identification
     * @param transactionId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cancelaPreAuthorization(contentType: string, accept: string, creditAccountId: string, transactionId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public cancelaPreAuthorization(contentType: string, accept: string, creditAccountId: string, transactionId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public cancelaPreAuthorization(contentType: string, accept: string, creditAccountId: string, transactionId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public cancelaPreAuthorization(contentType: string, accept: string, creditAccountId: string, transactionId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling cancelaPreAuthorization.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling cancelaPreAuthorization.');
        }
        if (creditAccountId === null || creditAccountId === undefined) {
            throw new Error('Required parameter creditAccountId was null or undefined when calling cancelaPreAuthorization.');
        }
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling cancelaPreAuthorization.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts/${this.configuration.encodeParam({name: "creditAccountId", value: creditAccountId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/transactions/${this.configuration.encodeParam({name: "transactionId", value: transactionId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<any>('delete', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Change credit limit of an Account
     * Increase the credit limit of an account.
     * @param creditAccountId Credit account\&#39;s identifier
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param changecreditlimitofanAccountRequest1 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public changecreditlimitofanAccount(creditAccountId: string, accept: string, contentType: string, changecreditlimitofanAccountRequest1: ChangecreditlimitofanAccountRequest1, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain', context?: HttpContext, transferCache?: boolean}): Observable<object>;
    public changecreditlimitofanAccount(creditAccountId: string, accept: string, contentType: string, changecreditlimitofanAccountRequest1: ChangecreditlimitofanAccountRequest1, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<object>>;
    public changecreditlimitofanAccount(creditAccountId: string, accept: string, contentType: string, changecreditlimitofanAccountRequest1: ChangecreditlimitofanAccountRequest1, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<object>>;
    public changecreditlimitofanAccount(creditAccountId: string, accept: string, contentType: string, changecreditlimitofanAccountRequest1: ChangecreditlimitofanAccountRequest1, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'text/plain', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (creditAccountId === null || creditAccountId === undefined) {
            throw new Error('Required parameter creditAccountId was null or undefined when calling changecreditlimitofanAccount.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling changecreditlimitofanAccount.');
        }
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling changecreditlimitofanAccount.');
        }
        if (changecreditlimitofanAccountRequest1 === null || changecreditlimitofanAccountRequest1 === undefined) {
            throw new Error('Required parameter changecreditlimitofanAccountRequest1 was null or undefined when calling changecreditlimitofanAccount.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'text/plain'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts/${this.configuration.encodeParam({name: "creditAccountId", value: creditAccountId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/creditlimit`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<object>('put', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: changecreditlimitofanAccountRequest1,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Change tolerance of an account
     * Increase the credit limit of a checking account.
     * @param creditAccountId Credit account\&#39;s identification
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param changetoleranceofanaccountRequest1 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public changetoleranceofanaccount(creditAccountId: string, accept: string, contentType: string, changetoleranceofanaccountRequest1: ChangetoleranceofanaccountRequest1, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain', context?: HttpContext, transferCache?: boolean}): Observable<object>;
    public changetoleranceofanaccount(creditAccountId: string, accept: string, contentType: string, changetoleranceofanaccountRequest1: ChangetoleranceofanaccountRequest1, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<object>>;
    public changetoleranceofanaccount(creditAccountId: string, accept: string, contentType: string, changetoleranceofanaccountRequest1: ChangetoleranceofanaccountRequest1, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<object>>;
    public changetoleranceofanaccount(creditAccountId: string, accept: string, contentType: string, changetoleranceofanaccountRequest1: ChangetoleranceofanaccountRequest1, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'text/plain', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (creditAccountId === null || creditAccountId === undefined) {
            throw new Error('Required parameter creditAccountId was null or undefined when calling changetoleranceofanaccount.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling changetoleranceofanaccount.');
        }
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling changetoleranceofanaccount.');
        }
        if (changetoleranceofanaccountRequest1 === null || changetoleranceofanaccountRequest1 === undefined) {
            throw new Error('Required parameter changetoleranceofanaccountRequest1 was null or undefined when calling changetoleranceofanaccount.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'text/plain'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts/${this.configuration.encodeParam({name: "creditAccountId", value: creditAccountId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/tolerance`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<object>('put', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: changetoleranceofanaccountRequest1,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Close an Account
     * Closes an account.
     * @param creditAccountId Credit account\&#39;s identifier
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param closeanAccountRequest1 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public closeanAccount(creditAccountId: string, accept: string, contentType: string, closeanAccountRequest1: CloseanAccountRequest1, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public closeanAccount(creditAccountId: string, accept: string, contentType: string, closeanAccountRequest1: CloseanAccountRequest1, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public closeanAccount(creditAccountId: string, accept: string, contentType: string, closeanAccountRequest1: CloseanAccountRequest1, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public closeanAccount(creditAccountId: string, accept: string, contentType: string, closeanAccountRequest1: CloseanAccountRequest1, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (creditAccountId === null || creditAccountId === undefined) {
            throw new Error('Required parameter creditAccountId was null or undefined when calling closeanAccount.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling closeanAccount.');
        }
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling closeanAccount.');
        }
        if (closeanAccountRequest1 === null || closeanAccountRequest1 === undefined) {
            throw new Error('Required parameter closeanAccountRequest1 was null or undefined when calling closeanAccount.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts/${this.configuration.encodeParam({name: "creditAccountId", value: creditAccountId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<any>('delete', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: closeanAccountRequest1,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Pre Authorization
     * 
     * @param creditAccountId Credit account\&#39;s identification
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param createaPreAuthorizationRequest1 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createaPreAuthorization(creditAccountId: string, accept: string, contentType: string, createaPreAuthorizationRequest1: CreateaPreAuthorizationRequest1, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public createaPreAuthorization(creditAccountId: string, accept: string, contentType: string, createaPreAuthorizationRequest1: CreateaPreAuthorizationRequest1, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public createaPreAuthorization(creditAccountId: string, accept: string, contentType: string, createaPreAuthorizationRequest1: CreateaPreAuthorizationRequest1, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public createaPreAuthorization(creditAccountId: string, accept: string, contentType: string, createaPreAuthorizationRequest1: CreateaPreAuthorizationRequest1, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (creditAccountId === null || creditAccountId === undefined) {
            throw new Error('Required parameter creditAccountId was null or undefined when calling createaPreAuthorization.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling createaPreAuthorization.');
        }
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling createaPreAuthorization.');
        }
        if (createaPreAuthorizationRequest1 === null || createaPreAuthorizationRequest1 === undefined) {
            throw new Error('Required parameter createaPreAuthorizationRequest1 was null or undefined when calling createaPreAuthorization.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts/${this.configuration.encodeParam({name: "creditAccountId", value: creditAccountId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/transaction`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<any>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: createaPreAuthorizationRequest1,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create a Pre Authorization (using id)
     * 
     * @param creditAccountId Credit account\&#39;s identification
     * @param transactionId 
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param createaPreAuthorizationUsingidRequest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createaPreAuthorizationUsingid(creditAccountId: string, transactionId: string, accept: string, contentType: string, createaPreAuthorizationUsingidRequest: CreateaPreAuthorizationUsingidRequest, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public createaPreAuthorizationUsingid(creditAccountId: string, transactionId: string, accept: string, contentType: string, createaPreAuthorizationUsingidRequest: CreateaPreAuthorizationUsingidRequest, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public createaPreAuthorizationUsingid(creditAccountId: string, transactionId: string, accept: string, contentType: string, createaPreAuthorizationUsingidRequest: CreateaPreAuthorizationUsingidRequest, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public createaPreAuthorizationUsingid(creditAccountId: string, transactionId: string, accept: string, contentType: string, createaPreAuthorizationUsingidRequest: CreateaPreAuthorizationUsingidRequest, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (creditAccountId === null || creditAccountId === undefined) {
            throw new Error('Required parameter creditAccountId was null or undefined when calling createaPreAuthorizationUsingid.');
        }
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling createaPreAuthorizationUsingid.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling createaPreAuthorizationUsingid.');
        }
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling createaPreAuthorizationUsingid.');
        }
        if (createaPreAuthorizationUsingidRequest === null || createaPreAuthorizationUsingidRequest === undefined) {
            throw new Error('Required parameter createaPreAuthorizationUsingidRequest was null or undefined when calling createaPreAuthorizationUsingid.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts/${this.configuration.encodeParam({name: "creditAccountId", value: creditAccountId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/transactions/${this.configuration.encodeParam({name: "transactionId", value: transactionId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<any>('put', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: createaPreAuthorizationUsingidRequest,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create or Update Settlement
     * Debit a value from checking account.
     * @param creditAccountId Credit account\&#39;s identification
     * @param transactionId 
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param createorUpdateSettlementRequest1 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public createorUpdateSettlement(creditAccountId: string, transactionId: string, accept: string, contentType: string, createorUpdateSettlementRequest1: CreateorUpdateSettlementRequest1, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ThisoperationcausesthecreationofNinvoicesWhereNisthenumberofinstallmentsThefirstinvoicewillhaveaduedatewith30daysandthenextinvoiceswillhaveaduedate30daysawayfrompreviousinvoice>;
    public createorUpdateSettlement(creditAccountId: string, transactionId: string, accept: string, contentType: string, createorUpdateSettlementRequest1: CreateorUpdateSettlementRequest1, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ThisoperationcausesthecreationofNinvoicesWhereNisthenumberofinstallmentsThefirstinvoicewillhaveaduedatewith30daysandthenextinvoiceswillhaveaduedate30daysawayfrompreviousinvoice>>;
    public createorUpdateSettlement(creditAccountId: string, transactionId: string, accept: string, contentType: string, createorUpdateSettlementRequest1: CreateorUpdateSettlementRequest1, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ThisoperationcausesthecreationofNinvoicesWhereNisthenumberofinstallmentsThefirstinvoicewillhaveaduedatewith30daysandthenextinvoiceswillhaveaduedate30daysawayfrompreviousinvoice>>;
    public createorUpdateSettlement(creditAccountId: string, transactionId: string, accept: string, contentType: string, createorUpdateSettlementRequest1: CreateorUpdateSettlementRequest1, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (creditAccountId === null || creditAccountId === undefined) {
            throw new Error('Required parameter creditAccountId was null or undefined when calling createorUpdateSettlement.');
        }
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling createorUpdateSettlement.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling createorUpdateSettlement.');
        }
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling createorUpdateSettlement.');
        }
        if (createorUpdateSettlementRequest1 === null || createorUpdateSettlementRequest1 === undefined) {
            throw new Error('Required parameter createorUpdateSettlementRequest1 was null or undefined when calling createorUpdateSettlement.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts/${this.configuration.encodeParam({name: "creditAccountId", value: creditAccountId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/transactions/${this.configuration.encodeParam({name: "transactionId", value: transactionId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/settlement`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<ThisoperationcausesthecreationofNinvoicesWhereNisthenumberofinstallmentsThefirstinvoicewillhaveaduedatewith30daysandthenextinvoiceswillhaveaduedate30daysawayfrompreviousinvoice>('put', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: createorUpdateSettlementRequest1,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Decrease balance of an account
     * Create a debit value updating the account BALANCE.
     * @param creditAccountId Credit account\&#39;s identification
     * @param statementId 
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param decreasebalanceofanaccountRequest1 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public decreasebalanceofanaccount(creditAccountId: string, statementId: string, accept: string, contentType: string, decreasebalanceofanaccountRequest1: DecreasebalanceofanaccountRequest1, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public decreasebalanceofanaccount(creditAccountId: string, statementId: string, accept: string, contentType: string, decreasebalanceofanaccountRequest1: DecreasebalanceofanaccountRequest1, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public decreasebalanceofanaccount(creditAccountId: string, statementId: string, accept: string, contentType: string, decreasebalanceofanaccountRequest1: DecreasebalanceofanaccountRequest1, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public decreasebalanceofanaccount(creditAccountId: string, statementId: string, accept: string, contentType: string, decreasebalanceofanaccountRequest1: DecreasebalanceofanaccountRequest1, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (creditAccountId === null || creditAccountId === undefined) {
            throw new Error('Required parameter creditAccountId was null or undefined when calling decreasebalanceofanaccount.');
        }
        if (statementId === null || statementId === undefined) {
            throw new Error('Required parameter statementId was null or undefined when calling decreasebalanceofanaccount.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling decreasebalanceofanaccount.');
        }
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling decreasebalanceofanaccount.');
        }
        if (decreasebalanceofanaccountRequest1 === null || decreasebalanceofanaccountRequest1 === undefined) {
            throw new Error('Required parameter decreasebalanceofanaccountRequest1 was null or undefined when calling decreasebalanceofanaccount.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts/${this.configuration.encodeParam({name: "creditAccountId", value: creditAccountId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/statements/${this.configuration.encodeParam({name: "statementId", value: statementId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<any>('put', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: decreasebalanceofanaccountRequest1,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete an account holder
     * 
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param creditAccountId Credit account\&#39;s identification
     * @param holderId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public deleteanaccountholder(contentType: string, accept: string, creditAccountId: string, holderId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<Searchcheckingaccounts1>;
    public deleteanaccountholder(contentType: string, accept: string, creditAccountId: string, holderId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Searchcheckingaccounts1>>;
    public deleteanaccountholder(contentType: string, accept: string, creditAccountId: string, holderId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Searchcheckingaccounts1>>;
    public deleteanaccountholder(contentType: string, accept: string, creditAccountId: string, holderId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling deleteanaccountholder.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling deleteanaccountholder.');
        }
        if (creditAccountId === null || creditAccountId === undefined) {
            throw new Error('Required parameter creditAccountId was null or undefined when calling deleteanaccountholder.');
        }
        if (holderId === null || holderId === undefined) {
            throw new Error('Required parameter holderId was null or undefined when calling deleteanaccountholder.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json; charset=utf-8'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts/${this.configuration.encodeParam({name: "creditAccountId", value: creditAccountId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/holders/${this.configuration.encodeParam({name: "holderId", value: holderId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Searchcheckingaccounts1>('delete', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Open an Account
     * Open an account.
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param openanAccountRequest1 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public openanAccount(accept: string, contentType: string, openanAccountRequest1: OpenanAccountRequest1, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<string>;
    public openanAccount(accept: string, contentType: string, openanAccountRequest1: OpenanAccountRequest1, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<string>>;
    public openanAccount(accept: string, contentType: string, openanAccountRequest1: OpenanAccountRequest1, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<string>>;
    public openanAccount(accept: string, contentType: string, openanAccountRequest1: OpenanAccountRequest1, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling openanAccount.');
        }
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling openanAccount.');
        }
        if (openanAccountRequest1 === null || openanAccountRequest1 === undefined) {
            throw new Error('Required parameter openanAccountRequest1 was null or undefined when calling openanAccount.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json; charset=utf-8'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<string>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: openanAccountRequest1,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Open or Change Account
     * Open or Change an account.
     * @param accountId It must be an alphanumeric value
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param openorChangeAccountRequest1 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public openorChangeAccount(accountId: string, accept: string, contentType: string, openorChangeAccountRequest1?: OpenorChangeAccountRequest1, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<string>;
    public openorChangeAccount(accountId: string, accept: string, contentType: string, openorChangeAccountRequest1?: OpenorChangeAccountRequest1, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<string>>;
    public openorChangeAccount(accountId: string, accept: string, contentType: string, openorChangeAccountRequest1?: OpenorChangeAccountRequest1, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<string>>;
    public openorChangeAccount(accountId: string, accept: string, contentType: string, openorChangeAccountRequest1?: OpenorChangeAccountRequest1, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling openorChangeAccount.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling openorChangeAccount.');
        }
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling openorChangeAccount.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json; charset=utf-8'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts/${this.configuration.encodeParam({name: "accountId", value: accountId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<string>('put', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: openorChangeAccountRequest1,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Partial or Total Refund a Settlement
     * Refund a value from a already settled transaction.
     * @param creditAccountId Credit account\&#39;s identification
     * @param transactionId 
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param partialorTotalRefundaSettlementRequest1 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public partialorTotalRefundaSettlement(creditAccountId: string, transactionId: string, accept: string, contentType: string, partialorTotalRefundaSettlementRequest1: PartialorTotalRefundaSettlementRequest1, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<ThisoperationcausesthecreationofNinvoicesWhereNisthenumberofinstallmentsThefirstinvoicewillhaveaduedatewith30daysandthenextinvoiceswillhaveaduedate30daysawayfrompreviousinvoice>;
    public partialorTotalRefundaSettlement(creditAccountId: string, transactionId: string, accept: string, contentType: string, partialorTotalRefundaSettlementRequest1: PartialorTotalRefundaSettlementRequest1, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ThisoperationcausesthecreationofNinvoicesWhereNisthenumberofinstallmentsThefirstinvoicewillhaveaduedatewith30daysandthenextinvoiceswillhaveaduedate30daysawayfrompreviousinvoice>>;
    public partialorTotalRefundaSettlement(creditAccountId: string, transactionId: string, accept: string, contentType: string, partialorTotalRefundaSettlementRequest1: PartialorTotalRefundaSettlementRequest1, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ThisoperationcausesthecreationofNinvoicesWhereNisthenumberofinstallmentsThefirstinvoicewillhaveaduedatewith30daysandthenextinvoiceswillhaveaduedate30daysawayfrompreviousinvoice>>;
    public partialorTotalRefundaSettlement(creditAccountId: string, transactionId: string, accept: string, contentType: string, partialorTotalRefundaSettlementRequest1: PartialorTotalRefundaSettlementRequest1, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (creditAccountId === null || creditAccountId === undefined) {
            throw new Error('Required parameter creditAccountId was null or undefined when calling partialorTotalRefundaSettlement.');
        }
        if (transactionId === null || transactionId === undefined) {
            throw new Error('Required parameter transactionId was null or undefined when calling partialorTotalRefundaSettlement.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling partialorTotalRefundaSettlement.');
        }
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling partialorTotalRefundaSettlement.');
        }
        if (partialorTotalRefundaSettlementRequest1 === null || partialorTotalRefundaSettlementRequest1 === undefined) {
            throw new Error('Required parameter partialorTotalRefundaSettlementRequest1 was null or undefined when calling partialorTotalRefundaSettlement.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts/${this.configuration.encodeParam({name: "creditAccountId", value: creditAccountId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/transactions/${this.configuration.encodeParam({name: "transactionId", value: transactionId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/refunds`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<ThisoperationcausesthecreationofNinvoicesWhereNisthenumberofinstallmentsThefirstinvoicewillhaveaduedatewith30daysandthenextinvoiceswillhaveaduedate30daysawayfrompreviousinvoice>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: partialorTotalRefundaSettlementRequest1,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve an Account by Id
     * Retrieve an account by id.
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param creditAccountId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public retrieveaAccountbyId(contentType: string, accept: string, creditAccountId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<Getaccount1>;
    public retrieveaAccountbyId(contentType: string, accept: string, creditAccountId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Getaccount1>>;
    public retrieveaAccountbyId(contentType: string, accept: string, creditAccountId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Getaccount1>>;
    public retrieveaAccountbyId(contentType: string, accept: string, creditAccountId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling retrieveaAccountbyId.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling retrieveaAccountbyId.');
        }
        if (creditAccountId === null || creditAccountId === undefined) {
            throw new Error('Required parameter creditAccountId was null or undefined when calling retrieveaAccountbyId.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json; charset=utf-8'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts/${this.configuration.encodeParam({name: "creditAccountId", value: creditAccountId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Getaccount1>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search all accounts
     * 
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public searchallaccounts(contentType: string, accept: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<Searchaccounts1>;
    public searchallaccounts(contentType: string, accept: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Searchaccounts1>>;
    public searchallaccounts(contentType: string, accept: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Searchaccounts1>>;
    public searchallaccounts(contentType: string, accept: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling searchallaccounts.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling searchallaccounts.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json; charset=utf-8'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Searchaccounts1>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update email and description of a account
     * Update a checking account.
     * @param creditAccountId Credit account\&#39;s identification
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param updateemailanddescriptionofaaccountRequest1 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public updateemailanddescriptionofaaccount(creditAccountId: string, accept: string, contentType: string, updateemailanddescriptionofaaccountRequest1: UpdateemailanddescriptionofaaccountRequest1, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<string>;
    public updateemailanddescriptionofaaccount(creditAccountId: string, accept: string, contentType: string, updateemailanddescriptionofaaccountRequest1: UpdateemailanddescriptionofaaccountRequest1, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<string>>;
    public updateemailanddescriptionofaaccount(creditAccountId: string, accept: string, contentType: string, updateemailanddescriptionofaaccountRequest1: UpdateemailanddescriptionofaaccountRequest1, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<string>>;
    public updateemailanddescriptionofaaccount(creditAccountId: string, accept: string, contentType: string, updateemailanddescriptionofaaccountRequest1: UpdateemailanddescriptionofaaccountRequest1, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (creditAccountId === null || creditAccountId === undefined) {
            throw new Error('Required parameter creditAccountId was null or undefined when calling updateemailanddescriptionofaaccount.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling updateemailanddescriptionofaaccount.');
        }
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling updateemailanddescriptionofaaccount.');
        }
        if (updateemailanddescriptionofaaccountRequest1 === null || updateemailanddescriptionofaaccountRequest1 === undefined) {
            throw new Error('Required parameter updateemailanddescriptionofaaccountRequest1 was null or undefined when calling updateemailanddescriptionofaaccount.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json; charset=utf-8'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts/${this.configuration.encodeParam({name: "creditAccountId", value: creditAccountId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<string>('put', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: updateemailanddescriptionofaaccountRequest1,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

}
