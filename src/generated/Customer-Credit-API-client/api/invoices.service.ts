/**
 * Customer Credit API
 *
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { ChangeInvoiceRequest1 } from '../model/changeInvoiceRequest1';
// @ts-ignore
import { Getinvoicesfromacheckingaccount1 } from '../model/getinvoicesfromacheckingaccount1';
// @ts-ignore
import { MarkaninvoiceasPaidRequest1 } from '../model/markaninvoiceasPaidRequest1';
// @ts-ignore
import { Paidinvoices1 } from '../model/paidinvoices1';
// @ts-ignore
import { PostponeaninvoiceRequest1 } from '../model/postponeaninvoiceRequest1';
// @ts-ignore
import { Retrievedinvoice1 } from '../model/retrievedinvoice1';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { BaseService } from '../api.base.service';



@Injectable({
  providedIn: 'root'
})
export class InvoicesService extends BaseService {

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string|string[], @Optional() configuration?: Configuration) {
        super(basePath, configuration);
    }

    /**
     * Cancel Invoice
     * Changes invoice\&#39;s status from ancells invoice by specified Id.
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param creditAccountId Credit account\&#39;s identification
     * @param invoiceId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public cancelInvoice(contentType: string, accept: string, creditAccountId: string, invoiceId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain', context?: HttpContext, transferCache?: boolean}): Observable<object>;
    public cancelInvoice(contentType: string, accept: string, creditAccountId: string, invoiceId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<object>>;
    public cancelInvoice(contentType: string, accept: string, creditAccountId: string, invoiceId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<object>>;
    public cancelInvoice(contentType: string, accept: string, creditAccountId: string, invoiceId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'text/plain', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling cancelInvoice.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling cancelInvoice.');
        }
        if (creditAccountId === null || creditAccountId === undefined) {
            throw new Error('Required parameter creditAccountId was null or undefined when calling cancelInvoice.');
        }
        if (invoiceId === null || invoiceId === undefined) {
            throw new Error('Required parameter invoiceId was null or undefined when calling cancelInvoice.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'text/plain'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts/${this.configuration.encodeParam({name: "creditAccountId", value: creditAccountId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/invoices/${this.configuration.encodeParam({name: "invoiceId", value: invoiceId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<object>('delete', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Change Invoice
     * Updates invoice\&#39;s attributes &#x60;status&#x60;, &#x60;paymentLink&#x60; and &#x60;observation&#x60;.
     * @param creditAccountId Credit account\&#39;s identification
     * @param invoiceId 
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param changeInvoiceRequest1 
     * @param friendlyId Invoice\&#39;s identification
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public changeInvoice(creditAccountId: string, invoiceId: string, accept: string, contentType: string, changeInvoiceRequest1: ChangeInvoiceRequest1, friendlyId?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain', context?: HttpContext, transferCache?: boolean}): Observable<object>;
    public changeInvoice(creditAccountId: string, invoiceId: string, accept: string, contentType: string, changeInvoiceRequest1: ChangeInvoiceRequest1, friendlyId?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<object>>;
    public changeInvoice(creditAccountId: string, invoiceId: string, accept: string, contentType: string, changeInvoiceRequest1: ChangeInvoiceRequest1, friendlyId?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<object>>;
    public changeInvoice(creditAccountId: string, invoiceId: string, accept: string, contentType: string, changeInvoiceRequest1: ChangeInvoiceRequest1, friendlyId?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'text/plain', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (creditAccountId === null || creditAccountId === undefined) {
            throw new Error('Required parameter creditAccountId was null or undefined when calling changeInvoice.');
        }
        if (invoiceId === null || invoiceId === undefined) {
            throw new Error('Required parameter invoiceId was null or undefined when calling changeInvoice.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling changeInvoice.');
        }
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling changeInvoice.');
        }
        if (changeInvoiceRequest1 === null || changeInvoiceRequest1 === undefined) {
            throw new Error('Required parameter changeInvoiceRequest1 was null or undefined when calling changeInvoice.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>friendlyId, 'friendlyId');

        let localVarHeaders = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'text/plain'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts/${this.configuration.encodeParam({name: "creditAccountId", value: creditAccountId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/invoices/${this.configuration.encodeParam({name: "invoiceId", value: invoiceId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<object>('put', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: changeInvoiceRequest1,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Mark an invoice as Paid
     * Pay an invoice.
     * @param creditAccountId Credit account\&#39;s identification
     * @param invoiceId 
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param markaninvoiceasPaidRequest1 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public markaninvoiceasPaid(creditAccountId: string, invoiceId: string, accept: string, contentType: string, markaninvoiceasPaidRequest1: MarkaninvoiceasPaidRequest1, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<string>;
    public markaninvoiceasPaid(creditAccountId: string, invoiceId: string, accept: string, contentType: string, markaninvoiceasPaidRequest1: MarkaninvoiceasPaidRequest1, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<string>>;
    public markaninvoiceasPaid(creditAccountId: string, invoiceId: string, accept: string, contentType: string, markaninvoiceasPaidRequest1: MarkaninvoiceasPaidRequest1, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<string>>;
    public markaninvoiceasPaid(creditAccountId: string, invoiceId: string, accept: string, contentType: string, markaninvoiceasPaidRequest1: MarkaninvoiceasPaidRequest1, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (creditAccountId === null || creditAccountId === undefined) {
            throw new Error('Required parameter creditAccountId was null or undefined when calling markaninvoiceasPaid.');
        }
        if (invoiceId === null || invoiceId === undefined) {
            throw new Error('Required parameter invoiceId was null or undefined when calling markaninvoiceasPaid.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling markaninvoiceasPaid.');
        }
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling markaninvoiceasPaid.');
        }
        if (markaninvoiceasPaidRequest1 === null || markaninvoiceasPaidRequest1 === undefined) {
            throw new Error('Required parameter markaninvoiceasPaidRequest1 was null or undefined when calling markaninvoiceasPaid.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json; charset=utf-8'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts/${this.configuration.encodeParam({name: "creditAccountId", value: creditAccountId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/invoices/${this.configuration.encodeParam({name: "invoiceId", value: invoiceId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/payments`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<string>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: markaninvoiceasPaidRequest1,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Postpone an invoice
     * Postpone an invoice.
     * @param creditAccountId Credit account\&#39;s identification
     * @param invoiceId 
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param postponeaninvoiceRequest1 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postponeaninvoice(creditAccountId: string, invoiceId: string, accept: string, contentType: string, postponeaninvoiceRequest1: PostponeaninvoiceRequest1, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain', context?: HttpContext, transferCache?: boolean}): Observable<object>;
    public postponeaninvoice(creditAccountId: string, invoiceId: string, accept: string, contentType: string, postponeaninvoiceRequest1: PostponeaninvoiceRequest1, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<object>>;
    public postponeaninvoice(creditAccountId: string, invoiceId: string, accept: string, contentType: string, postponeaninvoiceRequest1: PostponeaninvoiceRequest1, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'text/plain', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<object>>;
    public postponeaninvoice(creditAccountId: string, invoiceId: string, accept: string, contentType: string, postponeaninvoiceRequest1: PostponeaninvoiceRequest1, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'text/plain', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (creditAccountId === null || creditAccountId === undefined) {
            throw new Error('Required parameter creditAccountId was null or undefined when calling postponeaninvoice.');
        }
        if (invoiceId === null || invoiceId === undefined) {
            throw new Error('Required parameter invoiceId was null or undefined when calling postponeaninvoice.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling postponeaninvoice.');
        }
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling postponeaninvoice.');
        }
        if (postponeaninvoiceRequest1 === null || postponeaninvoiceRequest1 === undefined) {
            throw new Error('Required parameter postponeaninvoiceRequest1 was null or undefined when calling postponeaninvoice.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'text/plain'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts/${this.configuration.encodeParam({name: "creditAccountId", value: creditAccountId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/invoices/${this.configuration.encodeParam({name: "invoiceId", value: invoiceId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/postponement`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<object>('put', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: postponeaninvoiceRequest1,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve Invoice by Id
     * Returns associated data for the specified Invoice Id, like status  and value, for example.
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param creditAccountId Credit account\&#39;s identification
     * @param invoiceId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public retrieveInvoicebyId(contentType: string, accept: string, creditAccountId: string, invoiceId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<Retrievedinvoice1>;
    public retrieveInvoicebyId(contentType: string, accept: string, creditAccountId: string, invoiceId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Retrievedinvoice1>>;
    public retrieveInvoicebyId(contentType: string, accept: string, creditAccountId: string, invoiceId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Retrievedinvoice1>>;
    public retrieveInvoicebyId(contentType: string, accept: string, creditAccountId: string, invoiceId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling retrieveInvoicebyId.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling retrieveInvoicebyId.');
        }
        if (creditAccountId === null || creditAccountId === undefined) {
            throw new Error('Required parameter creditAccountId was null or undefined when calling retrieveInvoicebyId.');
        }
        if (invoiceId === null || invoiceId === undefined) {
            throw new Error('Required parameter invoiceId was null or undefined when calling retrieveInvoicebyId.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json; charset=utf-8'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts/${this.configuration.encodeParam({name: "creditAccountId", value: creditAccountId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/invoices/${this.configuration.encodeParam({name: "invoiceId", value: invoiceId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Retrievedinvoice1>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search all invoices
     * Returns all invoices according to the informed query params in the request.
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param from 
     * @param to 
     * @param createdDateFrom 
     * @param createdDateTo 
     * @param value Invoice\&#39;s value. It must be completed with a decimal value.
     * @param status Invoice\&#39;s status. It must be completed with \&quot;Paid\&quot;, \&quot;Cancelled\&quot; or \&quot;Open\&quot; value.
     * @param friendlyId Invoice\&#39;s identifier
     * @param creditAccountId Credit account\&#39;s identifier
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public searchallinvoices(contentType: string, accept: string, from?: string, to?: string, createdDateFrom?: string, createdDateTo?: string, value?: number, status?: string, friendlyId?: string, creditAccountId?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<Paidinvoices1>;
    public searchallinvoices(contentType: string, accept: string, from?: string, to?: string, createdDateFrom?: string, createdDateTo?: string, value?: number, status?: string, friendlyId?: string, creditAccountId?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Paidinvoices1>>;
    public searchallinvoices(contentType: string, accept: string, from?: string, to?: string, createdDateFrom?: string, createdDateTo?: string, value?: number, status?: string, friendlyId?: string, creditAccountId?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Paidinvoices1>>;
    public searchallinvoices(contentType: string, accept: string, from?: string, to?: string, createdDateFrom?: string, createdDateTo?: string, value?: number, status?: string, friendlyId?: string, creditAccountId?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling searchallinvoices.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling searchallinvoices.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>from, 'from');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>to, 'to');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>createdDateFrom, 'createdDateFrom');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>createdDateTo, 'createdDateTo');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>value, 'value');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>status, 'status');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>friendlyId, 'friendlyId');
        localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
          <any>creditAccountId, 'creditAccountId');

        let localVarHeaders = this.defaultHeaders;
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json; charset=utf-8'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/invoices`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Paidinvoices1>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Retrieve invoice by creditAccountId
     * Returns associated invoices by specified creditAccountId, the param that identifies a client in VTEX\&#39;s system.
     * @param contentType The Media type of the body of the request. Default value for payment provider protocol is application/json
     * @param accept Media type(s) that is/are acceptable for the response. Default value for payment provider protocol is application/json
     * @param creditAccountId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public searchallinvoicesofaAccount(contentType: string, accept: string, creditAccountId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<Getinvoicesfromacheckingaccount1>;
    public searchallinvoicesofaAccount(contentType: string, accept: string, creditAccountId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Getinvoicesfromacheckingaccount1>>;
    public searchallinvoicesofaAccount(contentType: string, accept: string, creditAccountId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Getinvoicesfromacheckingaccount1>>;
    public searchallinvoicesofaAccount(contentType: string, accept: string, creditAccountId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json; charset=utf-8', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling searchallinvoicesofaAccount.');
        }
        if (accept === null || accept === undefined) {
            throw new Error('Required parameter accept was null or undefined when calling searchallinvoicesofaAccount.');
        }
        if (creditAccountId === null || creditAccountId === undefined) {
            throw new Error('Required parameter creditAccountId was null or undefined when calling searchallinvoicesofaAccount.');
        }

        let localVarHeaders = this.defaultHeaders;
        if (contentType !== undefined && contentType !== null) {
            localVarHeaders = localVarHeaders.set('Content-Type', String(contentType));
        }
        if (accept !== undefined && accept !== null) {
            localVarHeaders = localVarHeaders.set('Accept', String(accept));
        }

        // authentication (appKey) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appKey', 'X-VTEX-API-AppKey', localVarHeaders);

        // authentication (appToken) required
        localVarHeaders = this.configuration.addCredentialToHeaders('appToken', 'X-VTEX-API-AppToken', localVarHeaders);

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            'application/json; charset=utf-8'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/creditcontrol/accounts/${this.configuration.encodeParam({name: "creditAccountId", value: creditAccountId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/invoices`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Getinvoicesfromacheckingaccount1>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

}
